# ----------------------------------------------------------------------
# Production Docker‑Compose for Citadel Quantum Trader (CQT)
# ----------------------------------------------------------------------
#   • Engine (primary & standby) – runs the Python trading bot,
#     exposes:
#        • 8005  – Flask ConfluenceController API (TLS terminated by the LB)
#        • 8000  – /metrics endpoint for Prometheus
#   • PostgreSQL / TimescaleDB – immutable ledger
#   • Prometheus – scrapes engine metrics, DB exporter, node‑exporter
#   • Grafana – Mission‑Control UI (auto‑imports datasource & dashboards)
#   • backup‑svc – tiny container that snapshots the DB volume & ships logs
# ----------------------------------------------------------------------
# NOTE:
#   • All secrets (DB password, API token, broker credentials, etc.)
#     are created **externally** on each engine droplet with:
#        docker secret create <NAME> -
#   • The .env file (checked‑in) holds static, non‑secret values.
#   • The VPC CIDR is assumed to be 10.10.0.0/16 – adjust if yours differs.
# ----------------------------------------------------------------------

version: "3.9"

# ----------------------------------------------------------------------
# Networks – a single isolated bridge network shared by all containers.
# ----------------------------------------------------------------------
networks:
  cqt-net:
    driver: bridge

# ----------------------------------------------------------------------
# Volumes – persistent storage for DB, Prometheus, Grafana.
# ----------------------------------------------------------------------
volumes:
  pg_data:          {}   # PostgreSQL data (NVMe block storage)
  prom_data:        {}   # Prometheus TSDB
  grafana_data:     {}   # Grafana dashboards / plugins

# ----------------------------------------------------------------------
# Services
# ----------------------------------------------------------------------
services:

  # --------------------------------------------------------------
  # 1️⃣  Engine – primary (the same compose file is used on the
  #     standby droplet – the only difference is the droplet’s
  #     private IP; the Load‑Balancer routes traffic to both.)
  # --------------------------------------------------------------
  engine:
    image: ghcr.io/${GITHUB_REPOSITORY_OWNER:-yourorg}/cqt-engine:latest
    container_name: cqt-engine
    restart: unless-stopped
    env_file: [.env]                     # static defaults (host, ports, modes)
    secrets:
      - POSTGRES_PASSWORD
      - CQT_API_TOKEN
      - MT5_PASSWORD
      - IBKR_API_KEY
      - IBKR_SECRET
    ports:
      - "8005:8005"   # ConfluenceController API (exposed to the LB)
      - "8000:8000"   # /metrics endpoint (scraped by Prometheus)
    depends_on:
      - db
    networks:
      - cqt-net
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8005/healthz"]
      interval: 10s
      timeout: 5s
      retries: 3

  # --------------------------------------------------------------
  # 2️⃣  PostgreSQL / TimescaleDB – immutable ledger
  # --------------------------------------------------------------
  db:
    image: ghcr.io/${GITHUB_REPOSITORY_OWNER:-yourorg}/cqt-db:latest
    container_name: cqt-db
    restart: unless-stopped
    environment:
      POSTGRES_USER: cqt_user
      POSTGRES_DB: cqt_ledger
      POSTGRES_PASSWORD_FILE: /run/secrets/POSTGRES_PASSWORD   # Docker‑Secret
    secrets:
      - POSTGRES_PASSWORD
    ports:
      - "5432:5432"
    volumes:
      - pg_data:/var/lib/postgresql/data
      - ./postgresql.conf:/etc/postgresql/postgresql.conf:ro
      - ./pg_hba.conf:/etc/postgresql/pg_hba.conf:ro
    command: ["postgres", "-c", "config_file=/etc/postgresql/postgresql.conf"]
    networks:
      - cqt-net
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "cqt_user"]
      interval: 10s
      timeout: 5s
      retries: 5

  # --------------------------------------------------------------
  # 3️⃣  Prometheus – metrics collector
  # --------------------------------------------------------------
  monitor:
    image: prom/prometheus:latest
    container_name: cqt-prometheus
    restart: unless-stopped
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - ./alert_rules.yml:/etc/prometheus/alert_rules.yml:ro
      - prom_data:/prometheus
    networks:
      - cqt-net
    depends_on:
      - engine
      - db
    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://localhost:9090/-/ready"]
      interval: 15s
      timeout: 5s
      retries: 3

  # --------------------------------------------------------------
  # 4️⃣  Node Exporter – system metrics (optional but handy)
  # --------------------------------------------------------------
  node_exporter:
    image: prom/node-exporter:latest
    container_name: cqt-node-exporter
    restart: unless-stopped
    pid: host
    network_mode: host   # gives direct host metrics
    depends_on:
      - monitor

  # --------------------------------------------------------------
  # 5️⃣  Grafana – Mission‑Control UI
  # --------------------------------------------------------------
  grafana:
    image: grafana/grafana:latest
    container_name: cqt-grafana
    restart: unless-stopped
    ports:
      - "3000:3000"
    environment:
      GF_SECURITY_ADMIN_PASSWORD: ${GF_ADMIN_PASS}
      GF_USERS_ALLOW_SIGN_UP: "false"
      GF_AUTH_ANONYMOUS_ENABLED: "false"
    volumes:
      - grafana_data:/var/lib/grafana
      - ./grafana-provisioning:/etc/grafana/provisioning
    networks:
      - cqt-net
    depends_on:
      - monitor
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/api/health"]
      interval: 15s
      timeout: 5s
      retries: 3

  # --------------------------------------------------------------
  # 6️⃣  Backup‑svc – tiny droplet (run on a separate VM, but we
  #     keep the definition here for completeness; you will
  #     `docker compose up -d backup` only on the backup VM.)
  # --------------------------------------------------------------
  backup:
    image: ghcr.io/${GITHUB_REPOSITORY_OWNER:-yourorg}/cqt-backup:latest
    container_name: cqt-backup
    restart: unless-stopped
    environment:
      DO_TOKEN: ${DO_PAT}
      AWS_ACCESS_KEY_ID: ${DO_SPACES_KEY}
      AWS_SECRET_ACCESS_KEY: ${DO_SPACES_SECRET}
    volumes:
      - pg_data:/srv/pg_data:ro          # read‑only mount of the DB volume
      - /var/log:/srv/logs:ro            # host logs (will be tarred & uploaded)
    networks:
      - cqt-net
    # No public ports – the backup VM only talks outbound to DO API & Spaces.
    # You will schedule the script via cron inside the container or on the host.

# ----------------------------------------------------------------------
# Docker Secrets – **external** (created on each engine droplet beforehand)
# ----------------------------------------------------------------------
secrets:
  POSTGRES_PASSWORD:
    external: true
  CQT_API_TOKEN:
    external: true
  MT5_PASSWORD:
    external: true
  IBKR_API_KEY:
    external: true
  IBKR_SECRET:
    external: true

    # -------------------------------------------------
# 7️⃣ Admin UI – FastAPI backend + React SPA
# -------------------------------------------------
admin-backend:
  build:
    context: ./admin_ui/backend
    dockerfile: Dockerfile
  container_name: citadel-admin-backend
  environment:
    # Secret for simple JWT (change in production!)
    - ADMIN_JWT_SECRET=${ADMIN_JWT_SECRET:-CHANGE_ME}
    # URL of the bot‑control service (the FastAPI wrapper we wrote)
    - BOT_CONTROL_URL=http://bot-control:8000
    # Prometheus endpoint (used by the draw‑down helper)
    - PROMETHEUS_URL=http://prometheus:9090
  depends_on:
    - bot-control
    - prometheus
  networks:
    - backend
  restart: unless-stopped

admin-frontend:
  build:
    context: ./admin_ui/frontend
    dockerfile: Dockerfile
  container_name: citadel-admin-frontend
  depends_on:
    - admin-backend
  networks:
    - backend
  restart: unless-stopped
  # The front‑end only serves static files, so we expose port 80 internally.
  # The outer Nginx (or the WireGuard‑only host) will expose it to the world.
  expose:
    - "80"

    # -------------------------------------------------
# 8️⃣ Nginx reverse‑proxy (TLS termination)
# -------------------------------------------------
nginx-proxy:
  image: nginx:alpine
  container_name: citadel-nginx
  ports:
    # Public HTTPS port – only this port is reachable from the Internet
    - "443:443"
  volumes:
    - ./nginx/conf.d:/etc/nginx/conf.d:ro
    - ./nginx/certs:/etc/nginx/certs:ro   # place your cert/key files here
  depends_on:
    - grafana-private
    - grafana-public
    - admin-frontend
  networks:
    - backend
  restart: unless-stopped
 citadel-bot:
  ...
  volumes:
    - ./heatmaps:/tmp/heatmaps   # host folder ./heatmaps maps to container /tmp/heatmaps

    citadel-bot:
  # … existing config …
  stop_grace_period: 30s          # give the app up to 30 s to finish
  # (optional) expose the stop signal explicitly
  # (Docker defaults to SIGTERM, but you can be explicit)
  # stop_signal: SIGTERM

  optimizer:
  build: ./admin_ui/optimizer   # (or ./optimizer if you keep it separate)
  container_name: citadel-optimizer
  environment:
    - OPT_WINDOW_DAYS=30
  volumes:
    - ./config:/app/config          # read/write the yaml files
    - ./data:/app/data              # market data (parquet/CSV)
    - ./optimizer/history:/opt/optimizer   # sqlite history DB
  command: ["python", "run_opt.py"]
  depends_on:
    - citadel-db
    - prometheus
  restart: unless-stopped

 # -------------------------------------------------
  # 10️⃣ Optimiser – runs the GA/Bayesian optimiser
  # -------------------------------------------------
  optimiser:
    image: citadel/optimiser:latest
    container_name: citadel-optimiser
    environment:
      # Path where the bot expects the config (shared volume)
      - CONFIG_DIR=/app/config
      # Optional: limit runtime (e.g., 2 h) to avoid runaway loops
      - RUN_INTERVAL=86400   # seconds (24 h). Set to 0 for “run once then exit”.
    volumes:
      - ./config:/app/config:rw   # shared with the bot – writable
    depends_on:
      - citadel-bot   # ensures the bot is up (optimiser can read metrics)
    networks:
      - backend
    restart: unless-stopped

    # -------------------------------------------------
# Optimiser – runs the GA (or CMA‑ES) on schedule
# -------------------------------------------------
optimiser:
  image: citadel/optimiser:latest
  container_name: citadel-optimiser
  environment:
    - TRAIN_DATA=/data/train.parquet
    - VAL_DATA=/data/val.parquet
    - OUT_CONFIG=/opt/config/new_config.yaml
    - RUN_INTERVAL=86400          # seconds between runs (24 h). Set 0 for one‑off.
  volumes:
    - ./data:/data:ro               # historic data (read‑only)
    - ./config:/opt/config:rw        # shared with the bot (hot‑reload)
  depends_on:
    - citadel-bot                   # ensures DB & broker are up
  networks:
    - backend
  restart: unless-stopped

  CMD ["sh", "-c", "while true; do python run_opt.py; sleep ${RUN_INTERVAL:-86400}; done"]

services:
  pushgateway:
    image: prom/pushgateway:latest
    ports:
      - "9091:9091"
    restart: unless-stopped
services:
  prometheus:
    image: prom/prometheus:latest
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
    ports:
      - "9090:9090"

  alertmanager:
    image: prom/alertmanager:latest
    volumes:
      - ./alertmanager.yml:/etc/alertmanager/config.yml
    ports:
      - "9093:9093"

alertmanager:
  image: prom/alertmanager:latest
  volumes:
    - ./alertmanager.yml:/etc/alertmanager/config.yml:ro
    - ./alertmanager_secrets:/etc/alertmanager/secrets:ro   # <-- new
  environment:
    - SLACK_WEBHOOK_URL=${SLACK_WEBHOOK_URL}

     global-risk-controller:
    build:
      context: ./admin_ui/global_risk_controller
      dockerfile: Dockerfile
    container_name: citadel-global-risk
    environment:
      - DB_URI=postgresql://citadel:${POSTGRES_PASSWORD}@citadel-db:5432/citadel
      - MAX_GLOBAL_RISK=0.05
    depends_on:
      - citadel-db
    networks:
      - backend
    restart: unless-stopped



 
