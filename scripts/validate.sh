#!/usr/bin/env bash
#=====================================================================
#  CQT â€“ Productionâ€‘ready validation harness
#
#  Location:   scripts/validate.sh
#  Called by:  go_live.sh   (after the engine containers have been
#                           pulled & started on BOTH engine droplets)
#
#  What it does
#  -------------
#  1ï¸âƒ£  Checks privateâ€‘IP reachability between all droplets.
#  2ï¸âƒ£  Verifies the DigitalOcean Loadâ€‘Balancer DNS and TLS healthâ€‘check.
#  3ï¸âƒ£  Confirms Dockerâ€‘Compose reports healthy containers on primary &
#      standby.
#  4ï¸âƒ£  Makes sure Prometheus sees both engines as UP.
#  5ï¸âƒ£  Tests the Grafana datasource (Prometheus) and the Missionâ€‘Control
#      Textâ€‘panel weightâ€‘update roundâ€‘trip.
#  6ï¸âƒ£  Executes a full paperâ€‘trade flow and validates the DB row.
#  7ï¸âƒ£  Enforces the maxâ€‘openâ€‘positions limit.
#  8ï¸âƒ£  Triggers a simulated drawâ€‘down â†’ verifies the killâ€‘switch.
#  9ï¸âƒ£  Performs a Loadâ€‘Balancer failâ€‘over test (stop primary, query API).
#  ðŸ”Ÿ  Fires a manual backupâ€‘svc run and checks that a recent snapshot
#      exists.
#  1ï¸âƒ£1ï¸âƒ£ Security sanity checks (API token required, SSH firewall).
#  1ï¸âƒ£2ï¸âƒ£ Alerting sanity check (highâ€‘risk alert fires).
#  1ï¸âƒ£3ï¸âƒ£ Performance baseline (CPU usage, Prometheus scrape latency).
#  1ï¸âƒ£4ï¸âƒ£ Writes a concise JSON summary for CI / audit logs.
#
#  Exit status: 0 = all checks passed, 1 = any failure.
#=====================================================================

set -euo pipefail

#---------------------------------------------------------------------
#  Load environment variables (generated by go_live.sh)
#---------------------------------------------------------------------
# The file must export at least the following vars:
#   LB_IP          â€“ public IP of the Managed Load Balancer
#   API_TOKEN      â€“ bearer token for the Flask API
#   GF_TOKEN       â€“ Grafana API token (admin)
#   PRIMARY_IP     â€“ private IP of the primary engine droplet
#   STANDBY_IP     â€“ private IP of the standby engine droplet
#   DB_IP          â€“ private IP of the PostgreSQL droplet
#   MONITOR_IP     â€“ private IP of the Prometheus droplet
#   GRAFANA_IP     â€“ private IP of the Grafana droplet
#   BACKUP_IP      â€“ private IP of the backupâ€‘svc droplet
#   LB_ID          â€“ DigitalOcean Loadâ€‘Balancer ID (used for healthâ€‘check)
#   VPC_CIDR       â€“ e.g. 10.10.0.0/16
#   ADMIN_IP       â€“ your own public IP (used for SSH firewall test)
#
# If the file does not exist the script aborts.
#---------------------------------------------------------------------
if [[ -f "./cqt_env.sh" ]]; then
    source "./cqt_env.sh"
else
    # âœ… FIXED: Redirect error message to stderr (>&2)
    echo "âŒ ERROR â€“ cqt_env.sh not found. Abort." >&2
    exit 1
fi

#---------------------------------------------------------------------
#  Helper functions
#  âœ… FIXED: Added explicit return statements to all functions
#---------------------------------------------------------------------
log() {
    echo -e "\e[32m[+] $*\e[0m"
    return 0
}

warn() {
    echo -e "\e[33m[!] $*\e[0m"
    return 0
}

error() {
    echo -e "\e[31m[âœ–] $*\e[0m" >&2
    return 1
}

die() {
    error "$*"
    exit 1
    # Explicit return for SonarCloud S1871 (unreachable but required)
    return 1
}

# Simple wrapper for curl that fails on nonâ€‘2xx codes
curl_ok() {
    local url=$1
    local hdrs=$2
    curl -sSf $hdrs "$url" >/dev/null
    return $?
}

#---------------------------------------------------------------------
#  âœ… FIXED: Added explicit return statement to check_compose_health
#---------------------------------------------------------------------
check_compose_health() {
    local host=$1
    ssh root@"$host" \
        "docker compose ps --format '{{.Service}} {{.State}} {{.Health}}'" |
        awk '/engine/ {if ($2!="running" || $3!="healthy") exit 1}'
    return $?
}

#---------------------------------------------------------------------
#  1ï¸âƒ£  Network sanity â€“ privateâ€‘IP reachability
#---------------------------------------------------------------------
log "ðŸ”Ž Verifying privateâ€‘IP reachability (SSH on port 22)"
for name in primary standby db monitor grafana backup; do
    ip_var="${name^^}_IP"
    ip="${!ip_var}"
    [[ -z "$ip" ]] && die "Variable $ip_var not set"
    if nc -zvw2 "$ip" 22 >/dev/null 2>&1; then
        log "$name ($ip) â€“ SSH reachable"
    else
        die "Cannot reach $name ($ip) on port 22"
    fi
done

#---------------------------------------------------------------------
#  2ï¸âƒ£  Loadâ€‘Balancer DNS & healthâ€‘check
#---------------------------------------------------------------------
log "ðŸ”Ž Resolving Loadâ€‘Balancer DNS"
resolved_ip=$(dig +short api.cqt.example.com | head -n1)
if [[ "$resolved_ip" != "$LB_IP" ]]; then
    die "LB DNS resolves to $resolved_ip, expected $LB_IP"
fi
log "âœ… LB DNS resolves correctly â†’ $resolved_ip"

log "ðŸ”Ž Testing LB health endpoint (HTTPS, bearer token)"
if ! curl_ok "https://api.cqt.example.com/healthz" \
            "-H \"Authorization: Bearer $API_TOKEN\" --max-time 5"; then
    die "LB health check failed"
fi
log "âœ… LB health endpoint OK (200)"

#---------------------------------------------------------------------
#  3ï¸âƒ£  Dockerâ€‘Compose health on primary & standby
#---------------------------------------------------------------------
log "ðŸ”Ž Verifying Dockerâ€‘Compose health on primary"
if ! check_compose_health "$PRIMARY_IP"; then
    die "Primary engine unhealthy"
fi
log "âœ… Primary engine healthy"

log "ðŸ”Ž Verifying Dockerâ€‘Compose health on standby"
if ! check_compose_health "$STANDBY_IP"; then
    die "Standby engine unhealthy"
fi
log "âœ… Standby engine healthy"

#---------------------------------------------------------------------
#  4ï¸âƒ£  Prometheus targets
#---------------------------------------------------------------------
log "ðŸ”Ž Fetching Prometheus target status"
targets=$(curl -s "http://$MONITOR_IP:9090/api/v1/targets")
echo "$targets" | jq -r '.data.activeTargets[] |
    "\(.labels.job) \(.health)"' |
while read -r job health; do
    if [[ "$health" != "up" ]]; then
        die "Prometheus target $job is $health"
    fi
done
log "âœ… All Prometheus targets are up"

#---------------------------------------------------------------------
#  5ï¸âƒ£  Grafana datasource sanity
#---------------------------------------------------------------------
log "ðŸ”Ž Checking Grafana datasource (expects Prometheus URL)"
ds=$(curl -s -H "Authorization: Bearer $GF_TOKEN" \
        "http://$GRAFANA_IP:3000/api/datasources")
echo "$ds" | jq -r '.[] |
    select(.type=="prometheus") |
    .url' |
grep -q "$MONITOR_IP:9090" || die "Grafana datasource not pointing to Prometheus"
log "âœ… Grafana datasource OK"

#---------------------------------------------------------------------
#  6ï¸âƒ£  Missionâ€‘Control UI â€“ weight roundâ€‘trip
#---------------------------------------------------------------------
log "ðŸ”Ž Testing weight update via Missionâ€‘Control"
new_weight=$(awk -v min=0.20 -v max=0.30 'BEGIN{srand(); printf "%.2f", min+rand()*(max-min)}')
curl -s -X POST "https://api.cqt.example.com/config/weight_mtf_structure" \
     -H "Authorization: Bearer $API_TOKEN" \
     -H "Content-Type: application/json" \
     -d "{\"value\":$new_weight}" >/dev/null

# Verify Prometheus gauge reflects the change
gauge=$(curl -s "http://$MONITOR_IP:9090/api/v1/query?query=confluence_parameter{parameter=\"weight_mtf_structure\"}" |
        jq -r '.data.result[0].value[1]')
if [[ "$gauge" != "$new_weight" ]]; then
    die "Gauge mismatch â€“ expected $new_weight, got $gauge"
fi
log "âœ… Weight update roundâ€‘trip succeeded (value=$new_weight)"

#---------------------------------------------------------------------
#  7ï¸âƒ£  Paperâ€‘trade endâ€‘toâ€‘end flow
#---------------------------------------------------------------------
log "ðŸ”Ž Submitting a paperâ€‘trade simulation"
sim_resp=$(curl -s -X POST "https://api.cqt.example.com/simulate" \
    -H "Authorization: Bearer $API_TOKEN" \
    -H "Content-Type: application/json" \
    -d '{"symbol":"EURUSD","direction":"BUY","entry_price":1.0800}')
trade_id=$(echo "$sim_resp" | jq -r '.trade_id // empty')
[[ -n "$trade_id" ]] || die "Simulation response missing trade_id"
log "âœ… Simulation submitted, trade_id=$trade_id"

log "ðŸ”Ž Verifying trade persisted in TimescaleDB"
db_check=$(ssh root@"$DB_IP" \
    "docker exec timescaledb psql -U cqt_user -d cqt_ledger -t -c \"SELECT trade_id FROM trades WHERE trade_id=$trade_id;\"")
if [[ "$db_check" != "$trade_id" ]]; then
    die "Trade $trade_id not found in DB"
fi
log "âœ… Trade $trade_id successfully stored"

#---------------------------------------------------------------------
#  8ï¸âƒ£  Positionâ€‘limit enforcement (max 4 open positions)
#---------------------------------------------------------------------
log "ðŸ”Ž Testing maxâ€‘openâ€‘positions limit (configured = 4)"
for i in {1..4}; do
    curl -s -X POST "https://api.cqt.example.com/simulate" \
        -H "Authorization: Bearer $API_TOKEN" \
        -H "Content-Type: application/json" \
        -d '{"symbol":"GBPUSD","direction":"BUY","entry_price":1.2600}' >/dev/null
done
# Fifth trade should be rejected
reject=$(curl -s -X POST "https://api.cqt.example.com/simulate" \
    -H "Authorization: Bearer $API_TOKEN" \
    -H "Content-Type: application/json" \
    -d '{"symbol":"USDJPY","direction":"BUY","entry_price":138.00}')
echo "$reject" | jq -e '.should_trade==false' >/dev/null ||
    die "Position limit not enforced"
log "âœ… Positionâ€‘limit correctly enforced"

#---------------------------------------------------------------------
#  9ï¸âƒ£  Killâ€‘switch (drawâ€‘down) test
#---------------------------------------------------------------------
log "ðŸ”Ž Forcing a >3 % daily drawâ€‘down to trigger killâ€‘switch"
ssh root@"$DB_IP" \
    "docker exec timescaledb psql -U cqt_user -d cqt_ledger -c \"UPDATE ledger_meta SET equity = equity * 0.94 WHERE id=1;\""
# Give the engine a few seconds to react
sleep 12
ks_status=$(curl -s "https://api.cqt.example.com/killswitch" \
    -H "Authorization: Bearer $API_TOKEN")
echo "$ks_status" | jq -e '.active==true' >/dev/null ||
    die "Killâ€‘switch did not activate"
log "âœ… Killâ€‘switch activated as expected"

#---------------------------------------------------------------------
#  ðŸ”Ÿ  Loadâ€‘Balancer failâ€‘over test
#---------------------------------------------------------------------
log "ðŸ”Ž Testing automatic failâ€‘over (stopping primary engine)"
ssh root@"$PRIMARY_IP" "docker compose stop engine"
# API should still respond via standby
curl -s -f "https://api.cqt.example.com/config" \
    -H "Authorization: Bearer $API_TOKEN" |
    jq . >/dev/null || die "API unreachable after primary stopped"
log "âœ… Failâ€‘over succeeded â€“ standby serving traffic"

log "ðŸ”Ž Restoring primary engine"
ssh root@"$PRIMARY_IP" "docker compose start engine"
sleep 5
lb_status=$(doctl compute load-balancer get "$LB_ID" --output json |
            jq -r '.droplet_ids | length')
if [[ "$lb_status" -ne 2 ]]; then
    die "Loadâ€‘balancer does not report two healthy droplets"
fi
log "âœ… Primary engine restored; both backâ€‘ends healthy"

#---------------------------------------------------------------------
#  1ï¸âƒ£1ï¸âƒ£  Backupâ€‘svc snapshot sanity check
#---------------------------------------------------------------------
log "ðŸ”Ž Triggering manual backup (snapshot + log archive)"
ssh root@"$BACKUP_IP" "/usr/local/bin/cqt_backup.sh"
snap=$(doctl compute snapshot list --resource-type volume --output json |
       jq -r '.[] | select(.name|contains("cqt-pg-data")) | .created_at' |
       head -n1)
[[ -n "$snap" ]] || die "No recent DB volume snapshot found"
log "âœ… Backup snapshot created at $snap"

#---------------------------------------------------------------------
#  1ï¸âƒ£2ï¸âƒ£  Security sanity checks
#---------------------------------------------------------------------
log "ðŸ”Ž Ensuring API rejects unauthenticated requests"
unauth_code=$(curl -s -o /dev/null -w "%{http_code}" \
    "https://api.cqt.example.com/config")
if [[ "$unauth_code" -ne 401 ]]; then
    die "Unauthenticated request returned $unauth_code (expected 401)"
fi
log "âœ… API correctly requires bearer token"

log "ðŸ”Ž Verifying SSH firewall (only admin IP allowed)"
# Try SSH from a throwâ€‘away container that is *not* in ADMIN_IP CIDR
temp_ip=$(docker run --rm alpine:latest ip -4 addr show eth0 |
          awk '/inet/ {print $2}' | cut -d/ -f1)
ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 \
    root@"$PRIMARY_IP" exit >/dev/null 2>&1 &&
    die "SSH succeeded from unauthorized IP $temp_ip" ||
    log "âœ… SSH correctly blocked from $temp_ip"

#---------------------------------------------------------------------
#  1ï¸âƒ£3ï¸âƒ£  Alerting sanity check (high risk fraction)
#---------------------------------------------------------------------
log "ðŸ”Ž Temporarily forcing high risk fraction to fire alert"
curl -s -X POST "https://api.cqt.example.com/config/min_total_score" \
     -H "Authorization: Bearer $API_TOKEN" \
     -H "Content-Type: application/json" \
     -d '{"value":10}' >/dev/null
# Give Alertmanager a moment to propagate
sleep 8
alert_state=$(curl -s -H "Authorization: Bearer $GF_TOKEN" \
    "http://$GRAFANA_IP:3000/api/alert-notifications" |
    jq -r '.[] | select(.state=="alerting") | .name' |
    grep -i "HighDynamicRisk" || true)
if [[ -n "$alert_state" ]]; then
    log "âœ… Alert triggered (HighDynamicRisk)"
else
    warn "âš ï¸ Alert did not fire â€“ check Alertmanager configuration"
fi

#---------------------------------------------------------------------
#  1ï¸âƒ£4ï¸âƒ£  Performance baseline (CPU & scrape latency)
#---------------------------------------------------------------------
log "ðŸ”Ž Collecting CPU usage snapshot on primary"
cpu_usage=$(ssh root@"$PRIMARY_IP" \
    "docker stats --no-stream --format '{{.CPUPerc}}' engine")
log "âœ… Primary engine CPU usage: $cpu_usage"

log "ðŸ”Ž Checking Prometheus scrape duration for engine targets"
scrape_ms=$(curl -s "http://$MONITOR_IP:9090/api/v1/query?query=prometheus_target_scrape_duration_seconds" |
            jq -r '.data.result[] |
                select(.metric.job=="cqt_engine") |
                .value[1]' |
            awk '{printf "%.0f", $1*1000}')
log "âœ… Average scrape duration for cqt_engine: ${scrape_ms} ms"

#---------------------------------------------------------------------
#  1ï¸âƒ£5ï¸âƒ£  Write a concise JSON summary (CI / audit friendly)
#---------------------------------------------------------------------
log "ðŸ”Ž Generating validationâ€‘run summary"
summary_file="/var/log/cqt_validation_summary.json"
cat > "$summary_file" <<EOF
{
  "timestamp": "$(date --utc +'%Y-%m-%dT%H:%M:%SZ')",
  "network": {
    "lb_dns_resolves_to": "$resolved_ip",
    "ssh_reachable": true
  },
  "services": {
    "primary_engine_healthy": true,
    "standby_engine_healthy": true,
    "prometheus_targets_up": true,
    "grafana_datasource_ok": true
  },
  "functional": {
    "weight_update_successful": true,
    "paper_trade_stored": true,
    "position_limit_enforced": true,
    "kill_switch_triggered": true,
    "failover_successful": true
  },
  "security": {
    "api_requires_token": true,
    "ssh_firewall_enforced": true
  },
  "alerts": {
    "high_dynamic_risk_fired": $( [[ -n "$alert_state" ]] && echo "true" || echo "false" )
  },
  "performance": {
    "engine_cpu_percent": "$cpu_usage",
    "prometheus_scrape_ms": $scrape_ms
  },
  "backup": {
    "snapshot_created": true,
    "snapshot_timestamp": "$snap"
  }
}
EOF
log "âœ… Validation summary written to $summary_file"

exit 0
